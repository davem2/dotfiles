export TERM="xterm-256color"

################################################################
# Auto-completion
#
autoload -U compinit
compinit

################################################################
# Keyboard
#
autoload zkbd
if [[ -f ~/.zkbd/$TERM-:0.0 ]]; then
    source ~/.zkbd/$TERM-:0.0
else
    zkbd # walk user through new keymap file if one doesn't exist
fi

[[ -n ${key[Backspace]} ]] && bindkey "${key[Backspace]}" backward-delete-char
[[ -n ${key[Insert]} ]] && bindkey "${key[Insert]}" overwrite-mode
[[ -n ${key[Home]} ]] && bindkey "${key[Home]}" beginning-of-line
[[ -n ${key[PageUp]} ]] && bindkey "${key[PageUp]}" up-line-or-history
[[ -n ${key[Delete]} ]] && bindkey "${key[Delete]}" delete-char
[[ -n ${key[End]} ]] && bindkey "${key[End]}" end-of-line
[[ -n ${key[PageDown]} ]] && bindkey "${key[PageDown]}" down-line-or-history
[[ -n ${key[Up]} ]] && bindkey "${key[Up]}" up-line-or-search
[[ -n ${key[Left]} ]] && bindkey "${key[Left]}" backward-char
[[ -n ${key[Down]} ]] && bindkey "${key[Down]}" down-line-or-search
[[ -n ${key[Right]} ]] && bindkey "${key[Right]}" forward-char


bindkey -e                          # emacs mode
#bindkey -v                         # vi mode

# History search
[[ -n "${key[PageUp]}"   ]]  && bindkey  "${key[PageUp]}"    history-beginning-search-backward
[[ -n "${key[PageDown]}" ]]  && bindkey  "${key[PageDown]}"  history-beginning-search-forward


################################################################
# History
#
HISTFILE=~/.histfile
HISTSIZE=10000
SAVEHIST=10000
setopt appendhistory                # append new history lines instead of overwriting
setopt HIST_IGNORE_DUPS             # prevent duplicate lines in history

################################################################
# Other options
#
setopt autocd                       # Change directory given just path
setopt extendedglob                 # Use additional pattern matching features
setopt notify

#unsetopt MULTIBYTE                  # recognize Meta and Alt keys

# if you do a 'rm *', Zsh will give you a sanity check!
setopt RM_STAR_WAIT

# allows you to type Bash style comments on your command line
# good 'ol Bash
setopt interactivecomments
setopt CORRECT                      # zsh spellcheck

unsetopt beep


setopt PRINT_EXIT_VALUE

################################################################
# Aliases
#
alias ls='ls -hF --group-directories-first --time-style=+"%d.%m.%Y %H:%M" --color=auto'
alias ll='ls -l'
alias la='ls -la'
alias lt='ls -lrt'                  # sort by modification time
alias lx='ls -lBX'                  # sort by extension
alias lz='ls -lrS'                  # sort by size

alias grep='grep --color=auto -d skip'
alias cp="cp -i"                    # confirm before overwriting something
alias df='df -h'                    # human readable
alias du='du -hc'                   # human readable
alias free='free -m'                # show sizes in MB
alias np='nano PKGBUILD'
alias pm='sudo pacman'
alias pk='packer --noconfirm --noedit'
alias cpufreq='watch grep \"cpu MHz\" /proc/cpuinfo'


################################################################
# Prompt
#
autoload -U promptinit
promptinit
#prompt clint

setopt prompt_subst
setopt promptsubst
setopt promptpercent

autoload colors; colors;

local return_code="%(?..%{$fg[red]%}✗ ❨%?❩ %{$reset_color%})"
local user_host='%{$fg[cyan]%}%n%{$reset_color%}@%{$fg[blue]%}%m%{$reset_color%}'
local current_dir='%{$fg[magenta]%}%~%{$reset_color%}'
local git_branch='$(git_prompt_info)%{$reset_color%}'

#RPROMPT="${return_code}%{$reset_color%} [%{$fg[magenta]%}%@%{$reset_color%}]"
RPROMPT="${return_code}%{$reset_color%}"
PROMPT="%{$fg_bold[blue]%}╭─[${current_dir}%{$fg_bold[blue]%}]${git_branch}
%{$fg_bold[blue]%}╰$%B%b "

ZSH_THEME_GIT_PROMPT_SUFFIX=""

# Git Prompt
function git_prompt_info() {
  ref=$(git symbolic-ref HEAD 2> /dev/null) || return
  ismod=$(git status --porcelain | head -1 | grep "^ M ")
  echo "%{$fg_bold[blue]%}(%{$fg_bold[yellow]%}${ref#refs/heads/}${ismod}%{$fg_bold[blue]%})%{$reset_color%}"
}


################################################################
# Dirstack
#
DIRSTACKFILE="$HOME/.cache/zsh/dirs"
if [[ -f $DIRSTACKFILE ]] && [[ $#dirstack -eq 0 ]]; then
  dirstack=( ${(f)"$(< $DIRSTACKFILE)"} )
  [[ -d $dirstack[1] ]] && cd $dirstack[1]
fi
chpwd() {
  print -l $PWD ${(u)dirstack} >$DIRSTACKFILE
}

DIRSTACKSIZE=20

setopt autopushd
setopt pushdsilent
setopt pushdtohome
setopt pushdignoredups              # remove duplicate entries
setopt pushdminus                   # this reverts the +/- operators
