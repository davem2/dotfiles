===============================================================================
=    W e l c o m e   t o   t h e   V I M   T u t o r    -  Part II  -  v1.7   =
===============================================================================

	 This tutor is designed to be used as a companion to the original VIM
	 tutor.  The original VIM tutor was designed to give a 30 minute hands on
	 introduction to basic Vim usage as an all-purpose editor.

     ATTENTION:
     The commands in the lessons will modify the text.  Make a copy of this
     file to practise on (if you started "vimtutor" this is already a copy).

     It is important to remember that this tutor is set up to teach by
     use.  That means that you need to execute the commands to learn them
     properly.  If you only read the text, you will forget the commands!


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MOVING AROUND REVIEW
  hjkl move the cursor left-down-up-right respectively.

w moves a word forward. b moves a word backward. These stop at punctuation,
too; if you want to skip a “word” where a word is just anything that’s not
whitespace, W and B do the trick. e moves forward until the end of a word,
instead of the start of a word. E has the same rule as above.

These are a good start: using wbWB are pretty good for getting around quickly.

You can prefix any command with a number; 5w moves 5 words, 10B moves backwards
10, uh, ‘big’, words. These work on hjkl as well (and almost anything,
honestly).

Go to the start and end of the line with ^$.

Go anywhere by searching with regular expressions; type /, and then complete
the regular expression in the buffer beneath. n and N then find the next and
previous match. These all function as movement commands in the below contexts,
too. ? is the same as /, but backwards. Note that n and N are reversed when
you’re in such a reverse search!

You can also go quickly to the following given character on the current line;
f followed by the character instantly goes there. fa will put the cursor on the
next a. Fa goes backwards. You can also go ‘til the next character, i.e. to the
character immediately before, with t; ta puts the cursor just before the
following a, and Ta just after the preceding one.

(You’ll note here that uppercase commands tend to vary the lowercase
equivalents, by degree, inversion, or other shift in meaning. I do say “tend”,
though, because there are plenty that don’t.)

<Enter> is another way of saying j, and <Space> another way of saying l.

) and ( move a sentence forward and backward respectively. } and { move by
paragraphs instead.

]}) and [( move to the next and previous unmatched ) and ( respectively, as do
)]} and [{ for } and {. More understandably put: they move out to the next
parenthesis or brace level in the given direction; they go “up” a level.

% moves to (and including) the matching token under the cursor; if your cursor
% is on a (, it’ll move to the matching ), etc.

G moves to the end of the document. gg moves to the start of the document. If
you prefix a number, it moves to that numbered line; 1G to the very top.




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 1.1:  MOVING THE CURSOR


   ** To move the cursor, press the h,j,k,l keys as indicated. **
	     ^
	     k		    Hint:  The h key is at the left and moves left.
       < h	 l >		   The l key is at the right and moves right.
	     j			   The j key looks like a down arrow.
	     v
  1. Move the cursor around the screen until you are comfortable.

  2. Hold down the down key (j) until it repeats.
     Now you know how to move to the next lesson.

  3. Using the down key, move to Lesson 1.2.

NOTE: If you are ever unsure about something you typed, press <ESC> to place
      you in Normal mode.  Then retype the command you wanted.

NOTE: The cursor keys should also work.  But using hjkl you will be able to
      move around much faster, once you get used to it.  Really!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			    Lesson 1.2: EXITING VIM


  !! NOTE: Before executing any of the steps below, read this entire lesson!!

  1. Press the <ESC> key (to make sure you are in Normal mode).

  2. Type:	:q! <ENTER>.
     This exits the editor, DISCARDING any changes you have made.

  3. When you see the shell prompt, type the command that got you into this
     tutor.  That would be:	vimtutor <ENTER>

  4. If you have these steps memorized and are confident, execute steps
     1 through 3 to exit and re-enter the editor.

NOTE:  :q! <ENTER>  discards any changes you made.  In a few lessons you
       will learn how to save the changes to a file.

  5. Move the cursor down to Lesson 1.3.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 1.3: TEXT EDITING - DELETION


	   ** Press  x  to delete the character under the cursor. **

  1. Move the cursor to the line below marked --->.

  2. To fix the errors, move the cursor until it is on top of the
     character to be deleted.

  3. Press the	x  key to delete the unwanted character.

  4. Repeat steps 2 through 4 until the sentence is correct.

---> The ccow jumpedd ovverr thhe mooon.

  5. Now that the line is correct, go on to Lesson 1.4.

NOTE: As you go through this tutor, do not try to memorize, learn by usage.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		      Lesson 1.4: TEXT EDITING - INSERTION


			** Press  i  to insert text. **

  1. Move the cursor to the first line below marked --->.

  2. To make the first line the same as the second, move the cursor on top
     of the first character AFTER where the text is to be inserted.

  3. Press  i  and type in the necessary additions.

  4. As each error is fixed press <ESC> to return to Normal mode.
     Repeat steps 2 through 4 to correct the sentence.

---> There is text misng this .
---> There is some text missing from this line.

  5. When you are comfortable inserting text move to lesson 1.5.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 1.5: TEXT EDITING - APPENDING


			** Press  A  to append text. **

  1. Move the cursor to the first line below marked --->.
     It does not matter on what character the cursor is in that line.

  2. Press  A  and type in the necessary additions.

  3. As the text has been appended press <ESC> to return to Normal mode.

  4. Move the cursor to the second line marked ---> and repeat
     steps 2 and 3 to correct this sentence.

---> There is some text missing from th
     There is some text missing from this line.
---> There is also some text miss
     There is also some text missing here.

  5. When you are comfortable appending text move to lesson 1.6.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 1.6: EDITING A FILE

		    ** Use  :wq  to save a file and exit. **

  !! NOTE: Before executing any of the steps below, read this entire lesson!!

  1. Exit this tutor as you did in lesson 1.2:  :q!
     Or, if you have access to another terminal, do the following there.

  2. At the shell prompt type this command:  vim tutor <ENTER>
     'vim' is the command to start the Vim editor, 'tutor' is the name of the
     file you wish to edit.  Use a file that may be changed.

  3. Insert and delete text as you learned in the previous lessons.

  4. Save the file with changes and exit Vim with:  :wq  <ENTER>

  5. If you have quit vimtutor in step 1 restart the vimtutor and move down to
     the following summary.

  6. After reading the above steps and understanding them: do it.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       Lesson 1 SUMMARY


  1. The cursor is moved using either the arrow keys or the hjkl keys.
	 h (left)	j (down)       k (up)	    l (right)

  2. To start Vim from the shell prompt type:  vim FILENAME <ENTER>

  3. To exit Vim type:	   <ESC>   :q!	 <ENTER>  to trash all changes.
	     OR type:	   <ESC>   :wq	 <ENTER>  to save the changes.

  4. To delete the character at the cursor type:  x

  5. To insert or append text type:
	 i   type inserted text   <ESC>		insert before the cursor
	 A   type appended text   <ESC>         append after the line

NOTE: Pressing <ESC> will place you in Normal mode or will cancel
      an unwanted and partially completed command.

Now continue with Lesson 2.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 2.1: DELETION COMMANDS


		       ** Type  dw  to delete a word. **

  1. Press  <ESC>  to make sure you are in Normal mode.

  2. Move the cursor to the line below marked --->.

  3. Move the cursor to the beginning of a word that needs to be deleted.

  4. Type   dw	 to make the word disappear.

  NOTE: The letter  d  will appear on the last line of the screen as you type
	it.  Vim is waiting for you to type  w .  If you see another character
	than  d  you typed something wrong; press  <ESC>  and start over.

---> There are a some words fun that don't belong paper in this sentence.

  5. Repeat steps 3 and 4 until the sentence is correct and go to Lesson 2.2.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		      Lesson 2.2: MORE DELETION COMMANDS


	   ** Type  d$	to delete to the end of the line. **

  1. Press  <ESC>  to make sure you are in Normal mode.

  2. Move the cursor to the line below marked --->.

  3. Move the cursor to the end of the correct line (AFTER the first . ).

  4. Type    d$    to delete to the end of the line.

---> Somebody typed the end of this line twice. end of this line twice.


  5. Move on to Lesson 2.3 to understand what is happening.





~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 2.3: ON OPERATORS AND MOTIONS


  Many commands that change text are made from an operator and a motion.
  The format for a delete command with the  d  delete operator is as follows:

  	d   motion

  Where:
    d      - is the delete operator.
    motion - is what the operator will operate on (listed below).

  A short list of motions:
    w - until the start of the next word, EXCLUDING its first character.
    e - to the end of the current word, INCLUDING the last character.
    $ - to the end of the line, INCLUDING the last character.

  Thus typing  de  will delete from the cursor to the end of the word.

NOTE:  Pressing just the motion while in Normal mode without an operator will
       move the cursor as specified.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 2.4: USING A COUNT FOR A MOTION


   ** Typing a number before a motion repeats it that many times. **

  1. Move the cursor to the start of the line marked ---> below.

  2. Type  2w  to move the cursor two words forward.

  3. Type  3e  to move the cursor to the end of the third word forward.

  4. Type  0  (zero) to move to the start of the line.

  5. Repeat steps 2 and 3 with different numbers.

---> This is just a line with words you can move around in.

  6. Move on to Lesson 2.5.




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 2.5: USING A COUNT TO DELETE MORE


   ** Typing a number with an operator repeats it that many times. **

  In the combination of the delete operator and a motion mentioned above you
  insert a count before the motion to delete more:
	 d   number   motion

  1. Move the cursor to the first UPPER CASE word in the line marked --->.

  2. Type  d2w  to delete the two UPPER CASE words

  3. Repeat steps 1 and 2 with a different count to delete the consecutive
     UPPER CASE words with one command

--->  this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up.





~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 Lesson 2.6: OPERATING ON LINES


		   ** Type  dd   to delete a whole line. **

  Due to the frequency of whole line deletion, the designers of Vi decided
  it would be easier to simply type two d's to delete a line.

  1. Move the cursor to the second line in the phrase below.
  2. Type  dd  to delete the line.
  3. Now move to the fourth line.
  4. Type   2dd   to delete two lines.

--->  1)  Roses are red,
--->  2)  Mud is fun,
--->  3)  Violets are blue,
--->  4)  I have a car,
--->  5)  Clocks tell time,
--->  6)  Sugar is sweet
--->  7)  And so are you.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 Lesson 2.7: THE UNDO COMMAND


   ** Press  u	to undo the last commands,   U  to fix a whole line. **

  1. Move the cursor to the line below marked ---> and place it on the
     first error.
  2. Type  x  to delete the first unwanted character.
  3. Now type  u  to undo the last command executed.
  4. This time fix all the errors on the line using the  x  command.
  5. Now type a capital  U  to return the line to its original state.
  6. Now type  u  a few times to undo the  U  and preceding commands.
  7. Now type CTRL-R (keeping CTRL key pressed while hitting R) a few times
     to redo the commands (undo the undo's).

---> Fiix the errors oon thhis line and reeplace them witth undo.

  8. These are very useful commands.  Now move on to the Lesson 2 Summary.




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       Lesson 2 SUMMARY


  1. To delete from the cursor up to the next word type:    dw
  2. To delete from the cursor to the end of a line type:    d$
  3. To delete a whole line type:    dd

  4. To repeat a motion prepend it with a number:   2w
  5. The format for a change command is:
               operator   [number]   motion
     where:
       operator - is what to do, such as  d  for delete
       [number] - is an optional count to repeat the motion
       motion   - moves over the text to operate on, such as  w (word),
		  $ (to the end of line), etc.

  6. To move to the start of the line use a zero:  0

  7. To undo previous actions, type: 	       u  (lowercase u)
     To undo all the changes on a line, type:  U  (capital U)
     To undo the undo's, type:		       CTRL-R

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 Lesson 3.1: THE PUT COMMAND


       ** Type	p  to put previously deleted text after the cursor. **

  1. Move the cursor to the first ---> line below.

  2. Type  dd  to delete the line and store it in a Vim register.

  3. Move the cursor to the c) line, ABOVE where the deleted line should go.

  4. Type   p   to put the line below the cursor.

  5. Repeat steps 2 through 4 to put all the lines in correct order.

---> d) Can you learn too?
---> b) Violets are blue,]
---> c) Intelligence is learned,
---> a) Roses are red,



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		       Lesson 3.2: THE REPLACE COMMAND


       ** Type  rx  to replace the character at the cursor with  x . **

  1. Move the cursor to the first line below marked --->.

  2. Move the cursor so that it is on top of the first error.

  3. Type   r	and then the character which should be there.

  4. Repeat steps 2 and 3 until the first line is equal to the second one.

--->  Whan this lime was tuoed in, someone presswd some wrojg keys!
--->  When this line was typed in, someone pressed some wrong keys!

  5. Now move on to Lesson 3.3.

NOTE: Remember that you should be learning by doing, not memorization.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 3.3: THE CHANGE OPERATOR


	   ** To change until the end of a word, type  ce . **

  1. Move the cursor to the first line below marked --->.

  2. Place the cursor on the  u  in  lubw.

  3. Type  ce  and the correct word (in this case, type  ine ).

  4. Press <ESC> and move to the next character that needs to be changed.

  5. Repeat steps 3 and 4 until the first sentence is the same as the second.

---> This lubw has a few wptfd that mrrf changing usf the change operator.
---> This line has a few words that need changing using the change operator.

Notice that  ce  deletes the word and places you in Insert mode.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		       Lesson 3.4: MORE CHANGES USING c


     ** The change operator is used with the same motions as delete. **

  1. The change operator works in the same way as delete.  The format is:

         c    [number]   motion

  2. The motions are the same, such as   w (word) and  $ (end of line).

  3. Move to the first line below marked --->.

  4. Move the cursor to the first error.

  5. Type  c$  and type the rest of the line like the second and press <ESC>.

---> The end of this line needs some help to make it like the second.
---> The end of this line needs to be corrected using the  c$  command.

NOTE:  You can use the Backspace key to correct mistakes while typing.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       Lesson 3 SUMMARY


  1. To put back text that has just been deleted, type   p .  This puts the
     deleted text AFTER the cursor (if a line was deleted it will go on the
     line below the cursor).

  2. To replace the character under the cursor, type   r   and then the
     character you want to have there.

  3. The change operator allows you to change from the cursor to where the
     motion takes you.  eg. Type  ce  to change from the cursor to the end of
     the word,  c$  to change to the end of a line.

  4. The format for change is:

	 c   [number]   motion

Now go on to the next lesson.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		  Lesson 4.1: CURSOR LOCATION AND FILE STATUS

  ** Type CTRL-G to show your location in the file and the file status.
     Type  G  to move to a line in the file. **

  NOTE: Read this entire lesson before executing any of the steps!!

  1. Hold down the Ctrl key and press  g .  We call this CTRL-G.
     A message will appear at the bottom of the page with the filename and the
     position in the file.  Remember the line number for Step 3.

NOTE:  You may see the cursor position in the lower right corner of the screen
       This happens when the 'ruler' option is set (see  :help 'ruler'  )

  2. Press  G  to move you to the bottom of the file.
     Type  gg  to move you to the start of the file.

  3. Type the number of the line you were on and then  G .  This will
     return you to the line you were on when you first pressed CTRL-G.

  4. If you feel confident to do this, execute steps 1 through 3.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 4.2: THE SEARCH COMMAND


     ** Type  /  followed by a phrase to search for the phrase. **

  1. In Normal mode type the  /  character.  Notice that it and the cursor
     appear at the bottom of the screen as with the  :	command.

  2. Now type 'errroor' <ENTER>.  This is the word you want to search for.

  3. To search for the same phrase again, simply type  n .
     To search for the same phrase in the opposite direction, type  N .

  4. To search for a phrase in the backward direction, use  ?  instead of  / .

  5. To go back to where you came from press  CTRL-O  (Keep Ctrl down while
     pressing the letter o).  Repeat to go back further.  CTRL-I goes forward.

--->  "errroor" is not the way to spell error;  errroor is an error.
NOTE: When the search reaches the end of the file it will continue at the
      start, unless the 'wrapscan' option has been reset.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		   Lesson 4.3: MATCHING PARENTHESES SEARCH


	      ** Type  %  to find a matching ),], or } . **

  1. Place the cursor on any (, [, or { in the line below marked --->.

  2. Now type the  %  character.

  3. The cursor will move to the matching parenthesis or bracket.

  4. Type  %  to move the cursor to the other matching bracket.

  5. Move the cursor to another (,),[,],{ or } and see what  %  does.

---> This ( is a test line with ('s, ['s ] and {'s } in it. ))


NOTE: This is very useful in debugging a program with unmatched parentheses!



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		      Lesson 4.4: THE SUBSTITUTE COMMAND


	** Type  :s/old/new/g  to substitute 'new' for 'old'. **

  1. Move the cursor to the line below marked --->.

  2. Type  :s/thee/the <ENTER> .  Note that this command only changes the
     first occurrence of "thee" in the line.

  3. Now type  :s/thee/the/g .  Adding the  g  flag means to substitute
     globally in the line, change all occurrences of "thee" in the line.

---> thee best time to see thee flowers is in thee spring.

  4. To change every occurrence of a character string between two lines,
     type   :#,#s/old/new/g    where #,# are the line numbers of the range
                               of lines where the substitution is to be done.
     Type   :%s/old/new/g      to change every occurrence in the whole file.
     Type   :%s/old/new/gc     to find every occurrence in the whole file,
     			       with a prompt whether to substitute or not.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       Lesson 4 SUMMARY


  1. CTRL-G  displays your location in the file and the file status.
             G  moves to the end of the file.
     number  G  moves to that line number.
            gg  moves to the first line.

  2. Typing  /	followed by a phrase searches FORWARD for the phrase.
     Typing  ?	followed by a phrase searches BACKWARD for the phrase.
     After a search type  n  to find the next occurrence in the same direction
     or  N  to search in the opposite direction.
     CTRL-O takes you back to older positions, CTRL-I to newer positions.

  3. Typing  %	while the cursor is on a (,),[,],{, or } goes to its match.

  4. To substitute new for the first old in a line type    :s/old/new
     To substitute new for all 'old's on a line type	   :s/old/new/g
     To substitute phrases between two line #'s type	   :#,#s/old/new/g
     To substitute all occurrences in the file type	   :%s/old/new/g
     To ask for confirmation each time add 'c'		   :%s/old/new/gc

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		Lesson 5.1: HOW TO EXECUTE AN EXTERNAL COMMAND


   ** Type  :!	followed by an external command to execute that command. **

  1. Type the familiar command	:  to set the cursor at the bottom of the
     screen.  This allows you to enter a command-line command.

  2. Now type the  !  (exclamation point) character.  This allows you to
     execute any external shell command.

  3. As an example type   ls   following the ! and then hit <ENTER>.  This
     will show you a listing of your directory, just as if you were at the
     shell prompt.  Or use  :!dir  if ls doesn't work.

NOTE:  It is possible to execute any external command this way, also with
       arguments.

NOTE:  All  :  commands must be finished by hitting <ENTER>
       From here on we will not always mention it.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		      Lesson 5.2: MORE ON WRITING FILES


     ** To save the changes made to the text, type  :w FILENAME. **

  1. Type  :!dir  or  :!ls  to get a listing of your directory.
     You already know you must hit <ENTER> after this.

  2. Choose a filename that does not exist yet, such as TEST.

  3. Now type:	 :w TEST   (where TEST is the filename you chose.)

  4. This saves the whole file (the Vim Tutor) under the name TEST.
     To verify this, type    :!dir  or  :!ls   again to see your directory.

NOTE: If you were to exit Vim and start it again with  vim TEST , the file
      would be an exact copy of the tutor when you saved it.

  5. Now remove the file by typing (MS-DOS):    :!del TEST
				or (Unix):	:!rm TEST


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		    Lesson 5.3: SELECTING TEXT TO WRITE


	** To save part of the file, type  v  motion  :w FILENAME **

  1. Move the cursor to this line.

  2. Press  v  and move the cursor to the fifth item below.  Notice that the
     text is highlighted.

  3. Press the  :  character.  At the bottom of the screen  :'<,'> will appear.

  4. Type  w TEST  , where TEST is a filename that does not exist yet.  Verify
     that you see  :'<,'>w TEST  before you press <ENTER>.

  5. Vim will write the selected lines to the file TEST.  Use  :!dir  or  :!ls
     to see it.  Do not remove it yet!  We will use it in the next lesson.

NOTE:  Pressing  v  starts Visual selection.  You can move the cursor around
       to make the selection bigger or smaller.  Then you can use an operator
       to do something with the text.  For example,  d  deletes the text.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		   Lesson 5.4: RETRIEVING AND MERGING FILES


       ** To insert the contents of a file, type  :r FILENAME  **

  1. Place the cursor just above this line.

NOTE:  After executing Step 2 you will see text from Lesson 5.3.  Then move
       DOWN to see this lesson again.

  2. Now retrieve your TEST file using the command   :r TEST   where TEST is
     the name of the file you used.
     The file you retrieve is placed below the cursor line.

  3. To verify that a file was retrieved, cursor back and notice that there
     are now two copies of Lesson 5.3, the original and the file version.

NOTE:  You can also read the output of an external command.  For example,
       :r !ls  reads the output of the ls command and puts it below the
       cursor.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       Lesson 5 SUMMARY


  1.  :!command  executes an external command.

      Some useful examples are:
	 (MS-DOS)	  (Unix)
	  :!dir		   :!ls		   -  shows a directory listing.
	  :!del FILENAME   :!rm FILENAME   -  removes file FILENAME.

  2.  :w FILENAME  writes the current Vim file to disk with name FILENAME.

  3.  v  motion  :w FILENAME  saves the Visually selected lines in file
      FILENAME.

  4.  :r FILENAME  retrieves disk file FILENAME and puts it below the
      cursor position.

  5.  :r !dir  reads the output of the dir command and puts it below the
      cursor position.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 Lesson 6.1: THE OPEN COMMAND


 ** Type  o  to open a line below the cursor and place you in Insert mode. **

  1. Move the cursor to the line below marked --->.

  2. Type the lowercase letter  o  to open up a line BELOW the cursor and place
     you in Insert mode.

  3. Now type some text and press <ESC> to exit Insert mode.

---> After typing  o  the cursor is placed on the open line in Insert mode.

  4. To open up a line ABOVE the cursor, simply type a capital	O , rather
     than a lowercase  o.  Try this on the line below.

---> Open up a line above this by typing O while the cursor is on this line.




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 6.2: THE APPEND COMMAND


	     ** Type  a  to insert text AFTER the cursor. **

  1. Move the cursor to the start of the line below marked --->.

  2. Press  e  until the cursor is on the end of  li .

  3. Type an  a  (lowercase) to append text AFTER the cursor.

  4. Complete the word like the line below it.  Press <ESC> to exit Insert
     mode.

  5. Use  e  to move to the next incomplete word and repeat steps 3 and 4.

---> This li will allow you to pract appendi text to a line.
---> This line will allow you to practice appending text to a line.

NOTE:  a, i and A all go to the same Insert mode, the only difference is where
       the characters are inserted.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		    Lesson 6.3: ANOTHER WAY TO REPLACE


      ** Type a capital  R  to replace more than one character. **

  1. Move the cursor to the first line below marked --->.  Move the cursor to
     the beginning of the first  xxx .

  2. Now press  R  and type the number below it in the second line, so that it
     replaces the xxx .

  3. Press <ESC> to leave Replace mode.  Notice that the rest of the line
     remains unmodified.

  4. Repeat the steps to replace the remaining xxx.

---> Adding 123 to xxx gives you xxx.
---> Adding 123 to 456 gives you 579.

NOTE:  Replace mode is like Insert mode, but every typed character deletes an
       existing character.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 6.4: COPY AND PASTE TEXT


	  ** Use the  y  operator to copy text and  p  to paste it **

  1. Go to the line marked with ---> below and place the cursor after "a)".

  2. Start Visual mode with  v  and move the cursor to just before "first".

  3. Type  y  to yank (copy) the highlighted text.

  4. Move the cursor to the end of the next line:  j$

  5. Type  p  to put (paste) the text.  Then type:  a second <ESC> .

  6. Use Visual mode to select " item.", yank it with  y , move to the end of
     the next line with  j$  and put the text there with  p .

--->  a) this is the first item.
      b)

  NOTE: you can also use  y  as an operator;  yw  yanks one word.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			    Lesson 6.5: SET OPTION


	  ** Set an option so a search or substitute ignores case **

  1. Search for 'ignore' by entering:   /ignore  <ENTER>
     Repeat several times by pressing  n .

  2. Set the 'ic' (Ignore case) option by entering:   :set ic

  3. Now search for 'ignore' again by pressing  n
     Notice that Ignore and IGNORE are now also found.

  4. Set the 'hlsearch' and 'incsearch' options:  :set hls is

  5. Now type the search command again and see what happens:  /ignore <ENTER>

  6. To disable ignoring case enter:  :set noic

NOTE:  To remove the highlighting of matches enter:   :nohlsearch
NOTE:  If you want to ignore case for just one search command, use  \c
       in the phrase:  /ignore\c  <ENTER>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       Lesson 6 SUMMARY

  1. Type  o  to open a line BELOW the cursor and start Insert mode.
     Type  O  to open a line ABOVE the cursor.

  2. Type  a  to insert text AFTER the cursor.
     Type  A  to insert text after the end of the line.

  3. The  e  command moves to the end of a word.

  4. The  y  operator yanks (copies) text,  p  puts (pastes) it.

  5. Typing a capital  R  enters Replace mode until  <ESC>  is pressed.

  6. Typing ":set xxx" sets the option "xxx".  Some options are:
  	'ic' 'ignorecase'	ignore upper/lower case when searching
	'is' 'incsearch'	show partial matches for a search phrase
	'hls' 'hlsearch'	highlight all matching phrases
     You can either use the long or the short option name.

  7. Prepend "no" to switch an option off:   :set noic

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		       Lesson 7.1: GETTING HELP


		      ** Use the on-line help system **

  Vim has a comprehensive on-line help system.  To get started, try one of
  these three:
	- press the <HELP> key (if you have one)
	- press the <F1> key (if you have one)
	- type   :help <ENTER>

  Read the text in the help window to find out how the help works.
  Type  CTRL-W CTRL-W   to jump from one window to another.
  Type    :q <ENTER>    to close the help window.

  You can find help on just about any subject, by giving an argument to the
  ":help" command.  Try these (don't forget pressing <ENTER>):

	:help w
	:help c_CTRL-D
	:help insert-index
	:help user-manual
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		      Lesson 7.2: CREATE A STARTUP SCRIPT


			  ** Enable Vim features **

  Vim has many more features than Vi, but most of them are disabled by
  default.  To start using more features you have to create a "vimrc" file.

  1. Start editing the "vimrc" file.  This depends on your system:
	:e ~/.vimrc		for Unix
	:e $VIM/_vimrc		for MS-Windows

  2. Now read the example "vimrc" file contents:
	:r $VIMRUNTIME/vimrc_example.vim

  3. Write the file with:
	:w

  The next time you start Vim it will use syntax highlighting.
  You can add all your preferred settings to this "vimrc" file.
  For more information type  :help vimrc-intro

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			     Lesson 7.3: COMPLETION


	      ** Command line completion with CTRL-D and <TAB> **

  1. Make sure Vim is not in compatible mode:  :set nocp

  2. Look what files exist in the directory:  :!ls   or  :!dir

  3. Type the start of a command:  :e

  4. Press  CTRL-D  and Vim will show a list of commands that start with "e".

  5. Press <TAB>  and Vim will complete the command name to ":edit".

  6. Now add a space and the start of an existing file name:  :edit FIL

  7. Press <TAB>.  Vim will complete the name (if it is unique).

NOTE:  Completion works for many commands.  Just try pressing CTRL-D and
       <TAB>.  It is especially useful for  :help .

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       Lesson 7 SUMMARY


  1. Type  :help  or press <F1> or <Help>  to open a help window.

  2. Type  :help cmd  to find help on  cmd .

  3. Type  CTRL-W CTRL-W  to jump to another window

  4. Type  :q  to close the help window

  5. Create a vimrc startup script to keep your preferred settings.

  6. When typing a  :  command, press CTRL-D to see possible completions.
     Press <TAB> to use one completion.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  This concludes the Vim Tutor.  It was intended to give a brief overview of
  the Vim editor, just enough to allow you to use the editor fairly easily.
  It is far from complete as Vim has many many more commands.  Read the user
  manual next: ":help user-manual".

  For further reading and studying, this book is recommended:
	Vim - Vi Improved - by Steve Oualline
	Publisher: New Riders
  The first book completely dedicated to Vim.  Especially useful for beginners.
  There are many examples and pictures.
  See http://iccf-holland.org/click5.html

  This book is older and more about Vi than Vim, but also recommended:
	Learning the Vi Editor - by Linda Lamb
	Publisher: O'Reilly & Associates Inc.
  It is a good book to get to know almost anything you want to do with Vi.
  The sixth edition also includes information on Vim.

  This tutorial was written by Michael C. Pierce and Robert K. Ware,
  Colorado School of Mines using ideas supplied by Charles Smith,
  Colorado State University.  E-mail: bware@mines.colorado.edu.

  Modified for Vim by Bram Moolenaar.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
move the cursor

hjkl move the cursor left-down-up-right respectively. It’s good to remember
these, but no big deal if you don’t; cursor keys usually work too. On Dvorak,
you have jk on your left hand for vertical movement, and hl on your right for
horizontal.

w moves a word forward. b moves a word backward. These stop at punctuation,
too; if you want to skip a “word” where a word is just anything that’s not
whitespace, W and B do the trick.

e moves forward until the end of a word, instead of the start of a word. E has
the same rule as above.

These are a good start: using wbWB are pretty good for getting around quickly.

You can prefix any command with a number; 5w moves 5 words, 10B moves backwards
10, uh, ‘big’, words. These work on hjkl as well (and almost anything,
honestly).

Go to the start and end of the line with ^$.

Go anywhere by searching with regular expressions; type /, and then complete
the regular expression in the buffer beneath. n and N then find the next and
previous match. These all function as movement commands in the below contexts,
too. ? is the same as /, but backwards. Note that n and N are reversed when
you’re in such a reverse search!

You can also go quickly to the following given character on the current line; f
followed by the character instantly goes there. fa will put the cursor on the
next a. Fa goes backwards. You can also go ‘til the next character, i.e. to the
character immediately before, with t; ta puts the cursor just before the
following a, and Ta just after the preceding one.

(You’ll note here that uppercase commands tend to vary the lowercase
equivalents, by degree, inversion, or other shift in meaning. I do say “tend”,
though, because there are plenty that don’t.)

<Enter> is another way of saying j, and <Space> another way of saying l.

) and ( move a sentence forward and backward respectively. } and { move by
paragraphs instead.

]}) and [( move to the next and previous unmatched ) and ( respectively, as do
)]} and [{ for } and {. More understandably put: they move out to the next
parenthesis or brace level in the given direction; they go “up” a level.

% moves to (and including) the matching token under the cursor; if your cursor
% is on a (, it’ll move to the matching ), etc.

G moves to the end of the document. If you prefix a number, it moves to that
numbered line; 1G to the very top.  delete

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
d deletes stuff. You have to tell it what by following with a movement command:
it deletes from the cursor position up to where you tell it. dw deletes the
word you’re on, up to the start of the next word. dl deletes up to the
following character; i.e. the single character your cursor is on.

Note that if you’ve hit d and change your mind, <Escape> will abort that
command.

Operations spanning lines are a bit different. dd will delete the entirety of
the current line. This repetition of a command to mean ‘this line’ is a
pattern. You can use a number: 2dd will delete this line and the one after it.
On that, 3dw deletes 3 words. (So does d3w.)

dj (delete down) will delete this and the next line. dk will delete this and
the previous line.

D is the same as d$; it deletes to the end of the line.

d/blah<Return> will delete from the cursor until the next blah in the file.
d?blah<Return> deletes back to the previous blah, including the entire matching
word itself.

dta deletes from the cursor up to and not including the following a. dfa would
include the a in its deletion. 2dta deletes up to and not including the second
following a, etc.

x deletes a single character, as a handy shorthand. If you have the word
programmer and the cursor positioned at the start, 10x will delete the whole
word.

d) will delete to the end of the sentence; as will d} the paragraph. d% deletes
the entirety of whatever the token under the cursor delimits; if your cursor is
on a matched brace, the entire brace will be deleted, and so on.  enter insert
mode

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
i will enter insert mode, leaving the cursor where it is.

a will enter insert mode, but places the cursor after the current character,
i.e. appends.

I and A enter insert mode, but first move the cursor to the start or end of the
line respectively. (These are handy.) They’re the same as ^i or $a
respectively.

Note that numbers work with these too: 3i will enter insert mode, and whatever
you type will be inserted thrice in total, once you leave the mode.

o and O enter insert mode, “opening” a line as they do. o opens a new line
underneath (same as A<Return>), and O opens a line on the current line (same as
I<Return><Escape>ki, or just ko if there’s a line above). You might need a
mnemonic to remember which is which; O reaches higher up the screen than o, and
so opens the line higher.

R enters replace mode; like insert, but overwriting text instead of inserting
before it.  delete then insert

You can delete then insert in the same command; this is called “changing” text.
Just use c instead of d, and it functions nearly identically as for deleting,
and then enters insert mode on the spot. (cw is the same as dei; cc is the same
as ^Di; the differences are that the whole object isn’t removed, that is to
say, trailing spaces or newlines are kept. ce and cw do the same thing.)

C functions as Di. Change is often handy as c/, ct, cT, etc.

Note that numbers before change commands affect only the delete portion of the
command; 2cw is literally like 2dei, not 2dei2i, in that it removes two words
(excluding the trailing space), and then enters insert mode, but what you
insert isn’t entered twice. This is almost always what you want.

s is like cl; it’ll change a character on your cursor. 10s erases the ten
characters from under your cursor and enters insert. S is the same as cc (since
otherwise what would it do different to C?).

r is like s but only for a single character; it waits for you to enter the
character, which the one under the cursor will be replaced with. 10ra replaces
the current and following 9 characters with the letter a.  enter visual mode

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
v enters visual mode. The cursor position at the time of entering visual mode
becomes one end of the selection, and now you move the other.

Visual mode selects a range of text, traversing newlines as they occur
sequentially in the text.

V enters visual line mode; this selects whole lines at a time, inclusive of
both ends of the selection.

CTRL-V enters visual block mode; this selects a physical rectangular block of
text. It can be a bit weird at first, especially with its behaviour crossing
lines and empty lines, but quite useful, especially in combination with r, c,
and s.

gv will enter visual mode with the last selection you had already made. (Note
that your cursor won’t necessarily be anywhere near where it ends up.) yank and
put

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
y takes a movement like other commands; yy (copies) yanks the current line, yj
the current and next, y2w (or 2yw) the two words from the cursor position
onward, etc.

p puts (pastes) what was yanked after the cursor position. If you yanked
linewise (like the first two examples above), the put is linewise: they are put
as whole lines underneath the current one, as if you’d used o to open.

P yanks at the current cursor position, as if you used i to insert the text. If
you yanked linewise, it puts as if you used O to open.

All delete commands, including change commands c, s and so on, actually have
been the equivalent of “cut” operations. If you e.g. use cw to change a word, p
will then put the deleted word.

See below about different registers in case you want to save some text without
it getting clobbered by subsequent yanks or deletes.

If cursor keys are enabled, they probably will let you move the cursor in vim
without exiting insert mode.

<Escape> will leave insert mode, by the way.  scroll

There’s a submode of insert mode that seems to be called expand mode; <CTRL-X>
enables it. Any keypress not recognised by the mode will just be handled by
regular insert mode and quit the expand mode; of note are <CTRL-E> and
<CTRL-Y>, which scroll the window down and up respectively. Just start typing
to exit the mode.

It’s worth noting these scroll in normal mode, too.  put

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
You can also put text while in insert mode. <CTRL-R>" will put whatever you
last deleted or yanked; see below about registers for more on this; the " is
specifying the register to put.

You can get help on insert-mode keys, by they way, by typing something like
:help i_CTRL-R.  visual

do things to the selected area, move your cursor about within it do things to
the selected area

Any command, like c and d, will affect the selected mode en masse.  move your
cursor about within it

Pressing o will change the end of the selection you’re moving to the other end;
useful to adjust the selection.

The three visual modes, accessed with v, V and CTRL-V, are exited by pressing
the appropriate key again. You can switch between visual modes by pressing the
key for any other visual mode while already in one.  registers

When you delete or yank text, it’s put in a register; a clipboard, essentially.
Each register is identified by a character, and they’re referred to by
prefixing a ". "a is the a register, "F the F register, etc. There are special
registers; the unnamed register, "" (i.e. the register name is double-quote),
is what’s used by default by yank, delete and put.

To perform any register-affecting command with a given register, prefix the
entire command with the register reference; "ay$ yanks the rest of the line
into the "a register. "ap puts that. (Note that dcsxy always affect the ""
register, as well as any specified one.)

"_ is the blackhole register; it causes the command to affect no registers.
(This is the only exception to the parenthesis prior to this. Ahem.)

Per put in insert, <CTRL-R> waits for a register name; <CTRL-R>a in insert mode
will put the contents of the "a register.

Registers "0 thru "9 have special meaning; see |quote_number| (type :help
quote_number in normal mode) for more information.

If you specify a letter-named register with lowercase letters, you replace the
contents; "ayw sets the contents of the "a register to the word from the cursor
on. The same register reference but uppercase causes that register to be
appended to.

More special registers exist; see |registers|.  text objects

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Text objects are another way to select areas of text. They can’t be used as
movement commands in normal mode in and of themselves, as they refer to
regions; they may only be movement command arguments to commands that do
something to regions, such as d and c. They are, however, very useful.

I lied, though: they can be used directly in visual mode, which selects the
region they refer to. Experimenting with this is a good way to see how they
work.

Text object commands start with either i or a; the former selects an object not
including surrounding whitespace (“inner”), the latter includes surrounding
whitespace. (Much like i leaves the cursor put when entering insert mode, but a
moves it forward. It sort of makes sense.)

After that, you specify the kind of object; they’re based roughly on movement
commands. iw, for instance, refers to the word your cursor is on top of. diw
deletes the word your cursor is on. Note how this differs (usefully) from dw;
dw deletes forwards from the cursor until the start of the next word, whereas
diw deletes the entire word under the cursor, regardless of your cursor’s
position.

Some common use cases: change the word under the cursor: ciw. Delete the word
under the cursor entirely, closing any gaps: daw. Same, but take any
punctuation touching the word with it, too: daW.

Sentences and paragraphs are accessed with s and p, again, following i or a.
Give some of these a try in visual mode to see what I mean: enter visual mode,
then try iw, then aw. Try ip, then ap. (Note that these will put you in visual
line mode.)

Some of the most useful are the matching token operators: i[ (or i)] ­ there’s
no difference) will select the contents of the nearest matching [...], but not
the [] themselves. a[ (or a)]) include the tokens themselves.

Same works for {, (, <, ", ', `. Changing a string or HTML attribute quickly?
ci". Want to quickly start a selection with a given block of code? va{.

Repetition works: 2di( deletes everything in the second-closest pair of
parentheses, but not those parentheses themselves.

Editing HTML, t will work on HTML tags; it the contents of the nearest tag, at
the contents and opening and closing tags themselves.

These are really lovely. See |text-objects| for more.  what else?

This is not even close to an exhaustive list of things in vim.

There are recordings (macros), which can be extraordinarily powerful; see
|recording|. Note that they record and execute into and of the same registers
that you paste in, meaning you can paste out a recording, modify in the text,
then yank it back into the register for execution.

There are even more movement commands: * and # search for the word under the
cursor, ; and , repeat your last tTfF command forward and backward (again with
confusing reversing behaviour), ` and ' operate on marks set by m (see |mark|),
and there are a million more commands prefixed by g (see |g|) that either
modify the behaviour of the non g-prefixed command, or do something totally
different. It’s worth a look.

Further, there’s the entire command-line mode, accessed by pressing : in normal
mode. There are an enormous number of commands, many operating on ranges
(pressing : in visual will start the command-line with a range matching the
visually-selected lines); a useful one is s (see |:s|), for search-and-replace.

There’s ., which repeats your last command. Learn how it behaves in different
circumstances and use it.

Keyword completion, triggered directly with CTRL-N and CTRL-P or through expand
(^X) mode (see |i_CTRL-N|, |i_CTRL-X_CTRL-N|) just does a lookup based on
tokens in open files. There’s omnicomplete (|compl-omni|, |i_CTRL-X_CTRL-O|),
which can use plugins to intelligently autocomplete (like IntelliSense).

And a heck of a lot more, too.

Good luck!'`)}"`'")}]


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Your problem with Vim is that you don't grok vi.

You mention cutting with yy and complain that you almost never want to cut
whole lines. In fact programmers, editing source code, very often want to work
on whole lines, ranges of lines and blocks of code. However, yy is only one of
many way to yank text into the anonymous copy buffer (or "register" as it's
called in vi).

The "Zen" of vi is that you're speaking a language. The initial y is a verb.
The statement yy is a synonym for y_. The y is doubled up to make it easier to
type, since it is such a common operation.

This can also be expressed as dd P (delete the current line and paste a copy
back into place; leaving a copy in the anonymous register as a side effect).
The y and d "verbs" take any movement as their "subject." Thus yW is "yank from
here (the cursor) to the end of the current/next (big) word" and y'a is "yank
from here to the line containing the mark named 'a'."

If you only understand basic up, down, left, and right cursor movements then vi
will be no more productive than a copy of "notepad" for you. (Okay, you'll
still have syntax highlighting and the ability to handle files larger than a
piddling ~45KB or so; but work with me here).

vi has 26 "marks" and 26 "registers." A mark is set to any cursor location
using the m command. Each mark is designated by a single lower case letter.
Thus ma sets the 'a' mark to the current location, and mz sets the 'z' mark.
You can move to the line containing a mark using the ' (single quote) command.
Thus 'a moves to the beginning of the line containing the 'a' mark. You can
move to the precise location of any mark using the ` (backquote) command. Thus
`z will move directly to the exact location of the 'z' mark.

Because these are "movements" they can also be used as subjects for other
"statements."

So, one way to cut an arbitrary selection of text would be to drop a mark (I
usually use 'a' as my "first" mark, 'z' as my next mark, 'b' as another, and
'e' as yet another (I don't recall ever having interactively used more than
four marks in 15 years of using vi; one creates one's own conventions regarding
how marks and registers are used by macros that don't disturb one's interactive
context). Then we go to the other end of our desired text; we can start at
either end, it doesn't matter. Then we can simply use d`a to cut or y`a to
copy. Thus the whole process has a 5 keystrokes overhead (six if we started in
"insert" mode and needed to Esc out command mode). Once we've cut or copied
then pasting in a copy is a single keystroke: p.

I say that this is one way to cut or copy text. However, it is only one of
many. Frequently we can more succinctly describe the range of text without
moving our cursor around and dropping a mark. For example if I'm in a paragraph
of text I can use { and } movements to the beginning or end of the paragraph
respectively. So, to move a paragraph of text I cut it using { d} (3
keystrokes). (If I happen to already be on the first or last line of the
paragraph I can then simply use d} or d{ respectively.

The notion of "paragraph" defaults to something which is usually intuitively
reasonable. Thus it often works for code as well as prose.

Frequently we know some pattern (regular expression) that marks one end or the
other of the text in which we're interested. Searching forwards or backwards
are movements in vi. Thus they can also be used as "subjects" in our
"statements." So I can use d/foo to cut from the current line to the next line
containing the string "foo" and y?bar to copy from the current line to the most
recent (previous) line containing "bar." If I don't want whole lines I can
still use the search movements (as statements of their own), drop my mark(s)
and use the `x commands as described previously.

In addition to "verbs" and "subjects" vi also has "objects" (in the grammatical
sense of the term). So far I've only described the use of the anonymous
register. However, I can use any of the 26 "named" registers by prefixing the
"object" reference with " (the double quote modifier). Thus if I use "add I'm
cutting the current line into the 'a' register and if I use "by/foo then I'm
yanking a copy of the text from here to the next line containing "foo" into the
'b' register. To paste from a register I simply prefix the paste with the same
modifier sequence: "ap pastes a copy of the 'a' register's contents into the
text after the cursor and "bP pastes a copy from 'b' to before the current
line.

This notion of "prefixes" also adds the analogs of grammatical "adjectives" and
"adverbs' to our text manipulation "language." Most commands (verbs) and
movement (verbs or objects, depending on context) can also take numeric
prefixes. Thus 3J means "join the next three lines" and d5`} means "delete from
the current line through the end of the fifth paragraph down from here."

This is all intermediate level vi. None of it is Vim specific and there are far
more advanced tricks in vi if you're ready to learn them. If you were to master
just these intermediate concepts then you'd probably find that you rarely need
to write any macros because the text manipulation language is sufficiently
concise and expressive to do most things easily enough using the editor's
"native" language.  A sampling of more advanced tricks:

There are a number of : commands, most notably the :% s/foo/bar/g global
substitution technique. (That's not advanced but other : commands can be). The
whole : set of commands was historically inherited by vi's previous
incarnations as the ed (line editor) and later the ex (extended line editor)
utilities. In fact vi is so named because it's the visual interface to ex.

: commands normally operate over lines of text. ed and ex were written in an
era when terminal screens were uncommon and many terminals were "teletype"
(TTY) devices. So it was common to work from printed copies of the text, using
commands through an extremely terse interface (common connection speeds were
110 baud, or, roughly, 11 characters per second -- which is slower than a fast
typist; lags were common on multi-user interactive sessions; additionally there
was often some motivation to conserve paper).

So the syntax of most : commands includes an address or range of addresses
(line number) followed by a command. Naturally one could use literal line
numbers: :127,215 s/foo/bar to change the first occurrence of "foo" into "bar"
on each line between 127 and 215. One could also use some abbreviations such as
. or $ for current and last lines respectively. One could also use relative
prefixes + and - to refer to offsets after or before the curent line,
respectively. Thus: :.,$j meaning "from the current line to the last line, join
them all into one line". :% is synonymous with :1,$ (all the lines).

The :... g and :... v commands bear some explanation as they are incredibly
powerful. :... g is a prefix for "globally" applying a subsequent command to
all lines which match a pattern (regular expression) while :... v applies such
a command to all lines which do NOT match the given pattern ("v" from
"conVerse"). As with other ex commands these can be prefixed by
addressing/range references. Thus :.,+21g/foo/d means "delete any lines
containing the string "foo" from the current one through the next 21 lines"
while :.,$v/bar/d means "from here to the end of the file, delete any lines
which DON'T contain the string "bar."

It's interesting that the common Unix command grep was actually inspired by
this ex command (and is named after the way in which it was documented). The ex
command :g/re/p (grep) was the way they documented how to "globally" "print"
lines containing a "regular expression" (re). When ed and ex were used, the :p
command was one of the first that anyone learned and often the first one used
when editing any file. It was how you printed the current contents (usually
just one page full at a time using :.,+25p or some such).

Note that :% g/.../d or (its reVerse/conVerse counterpart: :% v/.../d are the
most common usage patterns. However there are couple of other ex commands which
are worth remembering:

We can use m to move lines around, and j to join lines. For example if you have
a list and you want to separate all the stuff matching (or conversely NOT
matching some pattern) without deleting them, then you can use something like:
:% g/foo/m$ ... and all the "foo" lines will have been moved to the end of the
file. (Note the other tip about using the end of your file as a scratch space).
This will have preserved the relative order of all the "foo" lines while having
extracted them from the rest of the list. (This would be equivalent to doing
something like: 1G!GGmap!Ggrep foo<ENTER>1G:1,'a g/foo'/d (copy the file to its
own tail, filter the tail through grep, and delete all the stuff from the
head).

To join lines usually I can find a pattern for all the lines which need to be
joined to their predecessor (all the lines which start with "^ " rather than "^
* " in some bullet list, for example). For that case I'd use: :% g/^ /-1j (for
every matching line, go up one line and join them). (BTW: for bullet lists
trying to search for the bullet lines and join to the next doesn't work for a
couple reasons ... it can join one bullet line to another, and it won't join
any bullet line to all of its continuations; it'll only work pairwise on the
matches).

Almost needless to mention you can use our old friend s (substitute) with the g
and v (global/converse-global) commands. Usually you don't need to do so.
However, consider some case where you want to perform a substitution only on
lines matching some other pattern. Often you can use a complicated pattern with
captures and use back references to preserve the portions of the lines that you
DON'T want to change. However, it will often be easier to separate the match
from the substitution: :% g/foo/s/bar/zzz/g -- for every line containing "foo"
substitute all "bar" with "zzz." (Something like :%
s/\(.*foo.*\)bar\(.*\)/\1zzz\2/g would only work for the cases those instances
of "bar" which were PRECEDED by "foo" on the same line; it's ungainly enough
already, and would have to be mangled further to catch all the cases where
"bar" preceded "foo")

The point is that there are more than just p, s, and d lines in the ex command
set.

The : addresses can also refer to marks. Thus you can use: :'a,'bg/foo/j to
join any line containing the string foo to its subsequent line, if it lies
between the lines between the 'a' and 'b' marks. (Yes, all of the preceding ex
command examples can be limited to subsets of the file's lines by prefixing
with these sorts of addressing expressions).

That's pretty obscure (I've only used something like that a few times in the
last 15 years). However, I'll freely admit that I've often done things
iteratively and interactively that could probably have been done more
efficiently if I'd taken the time to think out the correct incantation.

Another very useful vi or ex command is :r to read in the contents of another
file. Thus: :r foo inserts the contents of the file named "foo" at the current
line.

More powerful is the :r! command. This reads the results of a command. It's the
same as suspending the vi session, running a command, redirecting its output to
a temporary file, resuming your vi session, and reading in the contents from
the temp. file.

Even more powerful are the ! (bang) and :... ! (ex bang) commands. These also
execute external commands and read the results into the current text. However,
they also filter selections of our text through the command! This we can sort
all the lines in our file using 1G!Gsort (G is the vi "goto" command; it
defaults to going to the last line of the file, but can be prefixed by a line
number, such as 1, the first line). This is equivalent to the ex variant
:1,$!sort. Writers often use ! with the Unix fmt or fold utilities for
reformating or "word wrapping" selections of text. A very common macro is
{!}fmt (reformat the current paragraph). Programmers sometimes use it to run
their code, or just portions of it, through indent or other code reformatting
tools.

Using the :r! and ! commands means that any external utility or filter can be
treated as an extension of our editor. I have occasionally used these with
scripts that pulled data from a database, or with wget or lynx commands that
pulled data off a website, or ssh commands that pulled data from remote
systems.

Another useful ex command is :so (short for :source). This reads the contents
of a file as a series of commands. When you start vi it normally, implicitly,
performs a :source on ~/.exinitrc file (and Vim usually does this on ~/.vimrc,
naturally enough). The use of this is that you can change your editor profile
on the fly by simply sourcing in a new set of macros, abbreviations, and editor
settings. If you're sneaky you can even use this as a trick for storing
sequences of ex editing commands to apply to files on demand.

For example I have a seven line file (36 characters) which runs a file through
wc, and inserts a C-style comment at the top of the file containing that word
count data. I can apply that "macro" to a file by using a command like: vim
+'so mymacro.ex' ./mytarget

(The + command line option to vi and Vim is normally used to start the editing
session at a given line number. However it's a little known fact that one can
follow the + by any valid ex command/expression, such as a "source" command as
I've done here; for a simple example I have scripts which invoke: vi
+'/foo/d|wq!' ~/.ssh/known_hosts to remove an entry from my SSH known hosts
file non-interactively while I'm re-imaging a set of servers).

Usually it's far easier to write such "macros" using Perl, AWK, sed (which is,
in fact, like grep a utility inspired by the ed command).

The @ command is probably the most obscure vi command. In occasionally teaching
advanced systems administration courses for close to a decade I've met very few
people who've ever used it. @ executes the contents of a register as if it were
a vi or ex command.  Example: I often use: :r!locate ... to find some file on
my system and read its name into my document. From there I delete any
extraneous hits, leaving only the full path to the file I'm interested in.
Rather than laboriously Tab-ing through each component of the path (or worse,
if I happen to be stuck on a machine without Tab completion support in its copy
of vi) I just use:

    0i:r (to turn the current line into a valid :r command), "cdd (to delete
the line into the "c" register) and @c execute that command.

That's only 10 keystrokes (and the expression "cdd @c is effectively a finger
macro for me, so I can type it almost as quickly as any common six letter
word").  A sobering thought

I've only scratched to surface of vi's power and none of what I've described
here is even part of the "improvements" for which vim is named! All of what
I've described here should work on any old copy of vi from 20 or 30 years ago.

There are people who have used considerably more of vi's power than I ever
will.  V"))"))
